
@book{hoffstein_introduction_2014,
	address = {New York},
	edition = {2},
	series = {Undergraduate {Texts} in {Mathematics}},
	title = {An {Introduction} to {Mathematical} {Cryptography}},
	isbn = {978-1-4939-1710-5},
	url = {https://www.springer.com/gp/book/9781493917105},
	abstract = {This self-contained introduction to modern cryptography emphasizes the mathematics behind the theory of public key cryptosystems and digital signature schemes. The book focuses on these key topics while developing the mathematical tools needed for the construction and security analysis of diverse cryptosystems. Only basic linear algebra is required of the reader; techniques from algebra, number theory, and probability are introduced and developed as required. This text provides an ideal introduction for mathematics and computer science students to the mathematical foundations of modern cryptography. The book includes an extensive bibliography and index; supplementary materials are available online.The book covers a variety of topics that are considered central to mathematical cryptography. Key topics include:classical cryptographic constructions, such as Diffie–Hellmann key exchange, discrete logarithm-based cryptosystems, the RSA cryptosystem, and digital signatures;fundamental mathematical tools for cryptography, including primality testing, factorization algorithms, probability theory, information theory, and collision algorithms;an in-depth treatment of important cryptographic innovations, such as elliptic curves, elliptic curve and pairing-based cryptography, lattices, lattice-based cryptography, and the NTRU cryptosystem.The second edition of An Introduction to Mathematical Cryptography includes a significant revision of the material on digital signatures, including an earlier introduction to RSA, Elgamal, and DSA signatures, and new material on lattice-based signatures and rejection sampling. Many sections have been rewritten or expanded for clarity, especially in the chapters on information theory, elliptic curves, and lattices, and the chapter of additional topics has been expanded to include sections on digital cash and homomorphic encryption. Numerous new exercises have been included.},
	language = {en},
	urldate = {2021-01-15},
	publisher = {Springer-Verlag},
	author = {Hoffstein, Jeffrey and Pipher, Jill and Silverman, Joseph H.},
	year = {2014},
	doi = {10.1007/978-1-4939-1711-2},
	keywords = {Cryptography, Math},
	file = {Snapshot:/home/lucas/archive/Zotero/storage/7SLFIPYL/9781493917105.html:text/html},
}

@inproceedings{erbsen_simple_2019,
	address = {San Francisco, CA, USA},
	title = {Simple {High}-{Level} {Code} for {Cryptographic} {Arithmetic} - {With} {Proofs}, {Without} {Compromises}},
	isbn = {978-1-5386-6660-9},
	url = {https://ieeexplore.ieee.org/document/8835346/},
	doi = {10.1109/SP.2019.00005},
	abstract = {We introduce a new approach for implementing cryptographic arithmetic in short high-level code with machinechecked proofs of functional correctness. We further demonstrate that simple partial evaluation is sufﬁcient to transform such initial code into the fastest-known C code, breaking the decadesold pattern that the only fast implementations are those whose instruction-level steps were written out by hand.},
	language = {en},
	urldate = {2021-01-15},
	booktitle = {2019 {IEEE} {Symposium} on {Security} and {Privacy} ({SP})},
	publisher = {IEEE},
	author = {Erbsen, Andres and Philipoom, Jade and Gross, Jason and Sloan, Robert and Chlipala, Adam},
	month = may,
	year = {2019},
	pages = {1202--1219},
	file = {Erbsen et al. - 2019 - Simple High-Level Code for Cryptographic Arithmeti.pdf:/home/lucas/archive/Zotero/storage/9FU4W9CK/Erbsen et al. - 2019 - Simple High-Level Code for Cryptographic Arithmeti.pdf:application/pdf},
}

@inproceedings{reparaz_dude_2017,
	address = {Lausanne, Switzerland},
	title = {Dude, is my code constant time?},
	isbn = {978-3-9815370-8-6},
	url = {http://ieeexplore.ieee.org/document/7927267/},
	doi = {10.23919/DATE.2017.7927267},
	abstract = {This paper introduces dudect: a tool to assess whether a piece of code runs in constant time or not on a given platform. We base our approach on leakage detection techniques, resulting in a very compact, easy to use and easy to maintain tool. Our methodology ﬁts in around 300 lines of C and runs on the target platform. The approach is substantially different from previous solutions. Contrary to others, our solution requires no modeling of hardware behavior. Our solution can be used in black-box testing, yet beneﬁts from implementation details if available. We show the effectiveness of our approach by detecting several variable-time cryptographic implementations. We place a prototype implementation of dudect in the public domain.},
	language = {en},
	urldate = {2021-01-20},
	booktitle = {Design, {Automation} \& {Test} in {Europe} {Conference} \& {Exhibition} ({DATE}), 2017},
	publisher = {IEEE},
	author = {Reparaz, Oscar and Balasch, Josep and Verbauwhede, Ingrid},
	month = mar,
	year = {2017},
	pages = {1697--1702},
	file = {Reparaz et al. - 2017 - Dude, is my code constant time.pdf:/home/lucas/archive/Zotero/storage/75QL2SZI/Reparaz et al. - 2017 - Dude, is my code constant time.pdf:application/pdf},
}

@article{kocher_timing_1996,
	title = {Timing {Attacks} on {Implementations} of {Diffie}-{Hellman}, {RSA}, {DSS}, and {Other} {Systems}},
	abstract = {By carefully measuring the amount of time required to perform private key operations, attackers may be able to nd xed Di eHellman exponents, factor RSA keys, and break other cryptosystems. Against a vulnerable system, the attack is computationally inexpensive and often requires only known ciphertext. Actual systems are potentially at risk, including cryptographic tokens, network-based cryptosystems, and other applications where attackers can make reasonably accurate timing measurements. Techniques for preventing the attack for RSA and Di e-Hellman are presented. Some cryptosystems will need to be revised to protect against the attack, and new protocols and algorithms may need to incorporate measures to prevent timing attacks.},
	language = {en},
	author = {Kocher, Paul C},
	year = {1996},
	keywords = {Cryptography, RSA, Constant Time},
	pages = {10},
	file = {Kocher - Timing Attacks on Implementations of Di e-Hellman,.pdf:/home/lucas/archive/Zotero/storage/FDG676JN/Kocher - Timing Attacks on Implementations of Di e-Hellman,.pdf:application/pdf},
}

@article{brumley_remote_2005,
	series = {Web {Security}},
	title = {Remote timing attacks are practical},
	volume = {48},
	issn = {1389-1286},
	url = {http://www.sciencedirect.com/science/article/pii/S1389128605000125},
	doi = {10.1016/j.comnet.2005.01.010},
	abstract = {Timing attacks are usually used to attack weak computing devices such as smartcards. We show that timing attacks apply to general software systems. Specifically, we devise a timing attack against OpenSSL. Our experiments show that we can extract private keys from an OpenSSL-based web server running on a machine in the local network. Our results demonstrate that timing attacks against network servers are practical and therefore security systems should defend against them.},
	language = {en},
	number = {5},
	urldate = {2021-01-20},
	journal = {Computer Networks},
	author = {Brumley, David and Boneh, Dan},
	month = aug,
	year = {2005},
	keywords = {RSA, Chinese remainder, Montgomery reductions, SSL, Timing attack},
	pages = {701--716},
	file = {Brumley and Boneh - Remote Timing Attacks are Practical.pdf:/home/lucas/archive/Zotero/storage/EWNSKTHB/Brumley and Boneh - Remote Timing Attacks are Practical.pdf:application/pdf;ScienceDirect Snapshot:/home/lucas/archive/Zotero/storage/2ASCGPNI/S1389128605000125.html:text/html},
}

@misc{pornin_bearssl_2020,
	title = {{BearSSL} - {Constant}-{Time} {Crypto}},
	url = {https://www.bearssl.org/constanttime.html},
	urldate = {2021-01-20},
	author = {Pornin, Thomas},
	year = {2020},
	file = {BearSSL - Constant-Time Crypto:/home/lucas/archive/Zotero/storage/EJP2L2P6/constanttime.html:text/html},
}

@misc{pornin_bearssl_2020-1,
	title = {{BearSSL} - {Big} {Integer} {Design}},
	url = {https://www.bearssl.org/bigint.html},
	urldate = {2021-01-20},
	author = {Pornin, Thomas},
	year = {2020},
	file = {BearSSL - Big Integer Design:/home/lucas/archive/Zotero/storage/N8XPAQL7/bigint.html:text/html},
}

@article{yarom_cachebleed_2017,
	title = {{CacheBleed}: {A} {Timing} {Attack} on {OpenSSL} {Constant} {Time} {RSA}},
	abstract = {The scatter-gather technique is a commonly-implemented approach to prevent cache-based timing attacks. In this paper we show that scatter-gather is not constant-time. We implement a cache timing attack against the scatter-gather implementation used in the modular exponentiation routine in OpenSSL version 1.0.2f. Our attack exploits cache-bank conﬂicts on the Sandy Bridge microarchitecture. We have tested the attack on an Intel Xeon E5-2430 processor. For 4096-bit RSA our attack can fully recover the private key after observing 16,000 decryptions.},
	language = {en},
	author = {Yarom, Yuval and Genkin, Daniel and Heninger, Nadia},
	year = {2017},
	pages = {21},
	file = {Yarom et al. - CacheBleed A Timing Attack on OpenSSL Constant Ti.pdf:/home/lucas/archive/Zotero/storage/X2UGXDMV/Yarom et al. - CacheBleed A Timing Attack on OpenSSL Constant Ti.pdf:application/pdf},
}

@article{weiser_big_2020,
	title = {Big {Numbers} – {Big} {Troubles}: {Systematically} {Analyzing} {Nonce} {Leakage} in ({EC}){DSA} {Implementations}},
	abstract = {Side-channel attacks exploiting (EC)DSA nonce leakage easily lead to full key recovery. Although (EC)DSA implementations have already been hardened against side-channel leakage using the constant-time paradigm, the long-standing cat-andmouse-game of attacks and patches continues. In particular, current code review is prone to miss less obvious side channels hidden deeply in the call stack. To solve this problem, a systematic study of nonce leakage is necessary. We present a systematic analysis of nonce leakage in cryptographic implementations. In particular, we expand DATA, an open-source side-channel analysis framework, to detect nonce leakage. Our analysis identiﬁed multiple unknown nonce leakage vulnerabilities across all essential computation steps involving nonces. Among others, we uncover inherent problems in Bignumber implementations that break claimed constant-time guarantees of (EC)DSA implementations if secrets are close to a word boundary. We found that lazy resizing of Bignumbers in OpenSSL and LibreSSL yields a highly accurate and easily exploitable side channel, which has been acknowledged with two CVEs. Surprisingly, we also found a tiny but expressive leakage in the constant-time scalar multiplication of OpenSSL and BoringSSL. Moreover, in the process of reporting and patching, we identiﬁed newly introduced leakage with the support of our tool, thus preventing another attack-patch cycle. We open-source our tool, together with an intuitive graphical user interface we developed.},
	language = {en},
	author = {Weiser, Samuel and Bodner, Lukas and Schrammel, David and Spreitzer, Raphael},
	year = {2020},
	pages = {19},
	file = {Weiser et al. - Big Numbers – Big Troubles Systematically Analyzi.pdf:/home/lucas/archive/Zotero/storage/FWS2QUXS/Weiser et al. - Big Numbers – Big Troubles Systematically Analyzi.pdf:application/pdf},
}

@incollection{lopez_exponent_2011,
	address = {Berlin, Heidelberg},
	title = {Exponent {Blinding} {Does} {Not} {Always} {Lift} ({Partial}) {Spa} {Resistance} to {Higher}-{Level} {Security}},
	volume = {6715},
	isbn = {978-3-642-21553-7 978-3-642-21554-4},
	url = {http://link.springer.com/10.1007/978-3-642-21554-4_5},
	language = {en},
	urldate = {2021-01-28},
	booktitle = {Applied {Cryptography} and {Network} {Security}},
	publisher = {Springer Berlin Heidelberg},
	author = {Schindler, Werner and Itoh, Kouichi},
	editor = {Lopez, Javier and Tsudik, Gene},
	year = {2011},
	doi = {10.1007/978-3-642-21554-4_5},
	note = {Series Title: Lecture Notes in Computer Science},
	pages = {73--90},
	file = {Full Text:/home/lucas/archive/Zotero/storage/UNWAUVLK/Schindler and Itoh - 2011 - Exponent Blinding Does Not Always Lift (Partial) S.pdf:application/pdf},
}

@article{cabrera_aldaya_cache-timing_2019,
	title = {Cache-{Timing} {Attacks} on {RSA} {Key} {Generation}},
	issn = {2569-2925},
	url = {https://tches.iacr.org/index.php/TCHES/article/view/8350},
	doi = {10.46586/tches.v2019.i4.213-242},
	abstract = {During the last decade, constant-time cryptographic software has quickly transitioned from an academic construct to a concrete security requirement for real-world libraries. Most of OpenSSL’s constant-time code paths are driven by cryptosystem implementations enabling a dedicated ﬂag at runtime. This process is perilous, with several examples emerging in the past few years of the ﬂag either not being set or software defects directly mishandling the ﬂag. In this work, we propose a methodology to analyze security-critical software for side-channel insecure code path traversal. Applying our methodology to OpenSSL, we identify three new code paths during RSA key generation that potentially leak critical algorithm state. Exploiting one of these leaks, we design, implement, and mount a single trace cache-timing attack on the GCD computation step. We overcome several hurdles in the process, including but not limited to: (1) granularity issues due to word-size operands to the GCD function; (2) bulk processing of desynchronized trace data; (3) non-trivial error rate during information extraction; and (4) limited high-conﬁdence information on the modulus factors. Formulating lattice problem instances after obtaining and processing this limited information, our attack achieves roughly a 27\% success rate for key recovery using the empirical data from 10K trials.},
	language = {en},
	urldate = {2021-02-11},
	journal = {IACR Transactions on Cryptographic Hardware and Embedded Systems},
	author = {Cabrera Aldaya, Alejandro and Pereida García, Cesar and Alvarez Tapia, Luis Manuel and Brumley, Billy Bob},
	month = aug,
	year = {2019},
	pages = {213--242},
	file = {Cabrera Aldaya et al. - 2019 - Cache-Timing Attacks on RSA Key Generation.pdf:/home/lucas/archive/Zotero/storage/GQ2CYSVJ/Cabrera Aldaya et al. - 2019 - Cache-Timing Attacks on RSA Key Generation.pdf:application/pdf},
}

@article{gueron_efficient_2012,
	title = {Efficient software implementations of modular exponentiation},
	volume = {2},
	issn = {2190-8508, 2190-8516},
	url = {http://link.springer.com/10.1007/s13389-012-0031-5},
	doi = {10.1007/s13389-012-0031-5},
	abstract = {RSA computations have a significant effect on the workloads of SSL/TLS servers, and therefore their software implementations on general purpose processors are an important target for optimization. We concentrate here on 512-bit modular exponentiation, used for 1024-bit RSA. We propose optimizations in two directions. At the primitives’ level, we study and improve the performance of an “Almost” Montgomery Multiplication. At the exponentiation level, we propose a method to reduce the cost of protecting the w-ary exponentiation algorithm against cache/timing side channel attacks. Together, these lead to an efficient software implementation of 512-bit modular exponentiation, which outperforms the currently fastest publicly available alternative. When measured on the latest x86-64 architecture, the 2nd Generation Intel® Core™ processor, our implementation is 43\% faster than that of the current version of OpenSSL (1.0.0d).},
	language = {en},
	number = {1},
	urldate = {2021-02-12},
	journal = {Journal of Cryptographic Engineering},
	author = {Gueron, Shay},
	month = may,
	year = {2012},
	pages = {31--43},
	file = {Gueron - 2012 - Efficient software implementations of modular expo.pdf:/home/lucas/archive/Zotero/storage/MI25PLVM/Gueron - 2012 - Efficient software implementations of modular expo.pdf:application/pdf},
}

@article{bos_constant_2014,
	title = {Constant time modular inversion},
	volume = {4},
	issn = {2190-8508, 2190-8516},
	url = {http://link.springer.com/10.1007/s13389-014-0084-8},
	doi = {10.1007/s13389-014-0084-8},
	abstract = {Simple power analysis is a common technique to attack software implementations, especially in the realm of public-key cryptography. An eﬀective countermeasure to protect an implementation is to ensure constant (worst-case) runtime. In this paper we show how to modify an algorithm by Kaliski to compute the Montgomery inverse such that it can compute both the classical and Montgomery modular inverse in constant time. We demonstrate the eﬀectiveness by comparing it to the approach based on Fermat’s little theorem as used in the current simple power analysis resistant implementations in cryptography. Our implementation on the popular 32-bit ARM platform highlights the practical beneﬁts of this algorithm.},
	language = {en},
	number = {4},
	urldate = {2021-03-11},
	journal = {Journal of Cryptographic Engineering},
	author = {Bos, Joppe W.},
	month = nov,
	year = {2014},
	pages = {275--281},
	file = {Bos - 2014 - Constant time modular inversion.pdf:/home/lucas/archive/Zotero/storage/INBA254U/Bos - 2014 - Constant time modular inversion.pdf:application/pdf},
}

@book{knuth_art_1997,
	address = {USA},
	title = {The art of computer programming, volume 2 (3rd ed.): seminumerical algorithms},
	isbn = {978-0-201-89684-8},
	shorttitle = {The art of computer programming, volume 2 (3rd ed.)},
	publisher = {Addison-Wesley Longman Publishing Co., Inc.},
	author = {Knuth, Donald E.},
	year = {1997},
}

@book{shoup_computational_2009,
	address = {USA},
	edition = {2},
	title = {A {Computational} {Introduction} to {Number} {Theory} and {Algebra}},
	isbn = {978-0-521-51644-0},
	abstract = {This introductory book emphasizes algorithms and applications, such as cryptography and error correcting codes, and is accessible to a broad audience. The presentation alternates between theory and applications in order to motivate and illustrate the mathematics. The mathematical coverage includes the basics of number theory, abstract algebra and discrete probability theory. This edition now includes over 150 new exercises, ranging from the routine to the challenging, that flesh out the material presented in the body of the text, and which further develop the theory and present new applications. The material has also been reorganized to improve clarity of exposition and presentation. Ideal as a textbook for introductory courses in number theory and algebra, especially those geared towards computer science students.},
	publisher = {Cambridge University Press},
	author = {Shoup, Victor},
	year = {2009},
}

@article{bernstein_fast_2019,
	title = {Fast constant-time gcd computation and modular inversion},
	issn = {2569-2925},
	url = {https://tches.iacr.org/index.php/TCHES/article/view/8298},
	doi = {10.46586/tches.v2019.i3.340-398},
	abstract = {This paper introduces streamlined constant-time variants of Euclid’s algorithm, both for polynomial inputs and for integer inputs. As concrete applications, this paper saves time in (1) modular inversion for Curve25519, which was previously believed to be handled much more eﬃciently by Fermat’s method, and (2) key generation for the ntruhrss701 and sntrup4591761 lattice-based cryptosystems.},
	language = {en},
	urldate = {2021-03-27},
	journal = {IACR Transactions on Cryptographic Hardware and Embedded Systems},
	author = {Bernstein, Daniel J. and Yang, Bo-Yin},
	month = may,
	year = {2019},
	pages = {340--398},
	file = {Bernstein and Yang - 2019 - Fast constant-time gcd computation and modular inv.pdf:/home/lucas/archive/Zotero/storage/G7LKVRJ7/Bernstein and Yang - 2019 - Fast constant-time gcd computation and modular inv.pdf:application/pdf},
}

@article{hars_modular_2006,
	title = {Modular {Inverse} {Algorithms} {Without} {Multiplications} for {Cryptographic} {Applications}},
	volume = {2006},
	doi = {10.1186/1687-3963-2006-032192},
	abstract = {Hardware and algorithmic optimization techniques are presented to the left-shift, right-shift, and the traditional Euclidean-modular inverse algorithms. Theoretical arguments and extensive simulations determined the resulting expected running time. On many computational platforms these turn out to be the fastest known algorithms for moderate operand lengths. They are based on variants of Euclidean-type extended GCD algorithms. On the considered computational platforms for operand lengths used in cryptography, the fastest presented modular inverse algorithms need about twice the time of modular multiplications, or even less. Consequently, in elliptic curve cryptography delaying modular divisions is slower (affine coordinates are the best) and the RSA and ElGamal cryptosystems can be accelerated.},
	journal = {EURASIP Journal on Embedded Systems},
	author = {Hars, Laszlo},
	month = jan,
	year = {2006},
	pages = {032192},
	file = {Full Text:/home/lucas/archive/Zotero/storage/SZZLPJSK/Hars - 2006 - Modular Inverse Algorithms Without Multiplications.pdf:application/pdf},
}

@incollection{goos_new_2003,
	address = {Berlin, Heidelberg},
	title = {New {Algorithm} for {Classical} {Modular} {Inverse}},
	volume = {2523},
	isbn = {978-3-540-00409-7 978-3-540-36400-9},
	url = {http://link.springer.com/10.1007/3-540-36400-5_6},
	abstract = {The Montgomery inverse is used in cryptography for the computation of modular inverse of b modulo a, where a is a prime. We analyse existing algorithms from the point of view of their hardware implementation. We propose a new, hardware-optimal algorithm for the calculation of the classical modular inverse. The left-shift binary algorithm is shown to naturally calculate the classical modular inverse in fewer operations than the algorithm derived from the Montgomery inverse.},
	language = {en},
	urldate = {2021-03-27},
	booktitle = {Cryptographic {Hardware} and {Embedded} {Systems} - {CHES} 2002},
	publisher = {Springer Berlin Heidelberg},
	author = {Lórencz, Róbert},
	editor = {Goos, Gerhard and Hartmanis, Juris and van Leeuwen, Jan and Kaliski, Burton S. and Koç, çetin K. and Paar, Christof},
	year = {2003},
	doi = {10.1007/3-540-36400-5_6},
	note = {Series Title: Lecture Notes in Computer Science},
	pages = {57--70},
	file = {Lórencz - 2003 - New Algorithm for Classical Modular Inverse.pdf:/home/lucas/archive/Zotero/storage/2WDMW74D/Lórencz - 2003 - New Algorithm for Classical Modular Inverse.pdf:application/pdf},
}

@article{pornin_optimized_2020,
	title = {Optimized {Binary} {GCD} for {Modular} {Inversion}},
	abstract = {In this short note, we describe a practical optimization of the well-known extended binary GCD algorithm, for the purpose of computing modular inverses. The method is conceptually simple and is applicable to all odd moduli (including nonprime moduli). When implemented for inversion in the eld of integers modulo the prime − , on a recent x CPU (Co ee Lake core), we compute the inverse in cycles, with a fully constant-time implementation.},
	language = {en},
	author = {Pornin, Thomas},
	year = {2020},
	pages = {16},
	file = {Pornin - Optimized Binary GCD for Modular Inversion.pdf:/home/lucas/archive/Zotero/storage/XLV7JZBR/Pornin - Optimized Binary GCD for Modular Inversion.pdf:application/pdf},
}

@article{kaya_koc_analyzing_1996,
	title = {Analyzing and comparing {Montgomery} multiplication algorithms},
	volume = {16},
	issn = {02721732},
	url = {http://ieeexplore.ieee.org/document/502403/},
	doi = {10.1109/40.502403},
	abstract = {This paper discusses several Montgomery multiplication algorithms, two of which have been proposed before. We describe three additional algorithms, and analyze in detail the space and time requirements of all ve methods. These algorithms have been implemented in C and in assembler. The analyses and actual performance results indicate that the Coarsely Integrated Operand Scanning CIOS method, detailed in this paper, is the most e cient of all ve algorithms, at least for the general class of processor we considered. The Montgomery multiplication methods constitute the core of the modular exponentiation operation which is the most popular method used in public-key cryptography for encrypting and signing digital data.},
	language = {en},
	number = {3},
	urldate = {2021-03-30},
	journal = {IEEE Micro},
	author = {Kaya Koc, C. and Acar, T. and Kaliski, B.S.},
	month = jun,
	year = {1996},
	pages = {26--33},
	file = {Kaya Koc et al. - 1996 - Analyzing and comparing Montgomery multiplication .pdf:/home/lucas/archive/Zotero/storage/K9IJN3SF/Kaya Koc et al. - 1996 - Analyzing and comparing Montgomery multiplication .pdf:application/pdf},
}

@article{bernstein_cache-timing_2005,
	title = {Cache-timing attacks on {AES}},
	abstract = {This paper demonstrates complete AES key recovery from known-plaintext timings of a network server on another computer. This attack should be blamed on the AES design, not on the particular AES library used by the server; it is extremely diﬃcult to write constant-time high-speed AES software for common general-purpose computers. This paper discusses several of the obstacles in detail.},
	language = {en},
	author = {Bernstein, Daniel J},
	year = {2005},
	pages = {37},
	file = {Bernstein - Cache-timing attacks on AES.pdf:/home/lucas/archive/Zotero/storage/GP63FRK5/Bernstein - Cache-timing attacks on AES.pdf:application/pdf},
}

@inproceedings{grabher_cryptographic_2007,
	address = {Berlin, Heidelberg},
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {Cryptographic {Side}-{Channels} from {Low}-{Power} {Cache} {Memory}},
	isbn = {978-3-540-77272-9},
	doi = {10.1007/978-3-540-77272-9_11},
	abstract = {To deliver real world cryptographic applications, we are increasingly reliant on security guarantees from both the underlying mathematics and physical implementation. The micro-processors that execute such applications are often designed with a focus on performance, area or power consumption. This strategy neglects physical security, a fact that has recently been exploited by a new breed of micro-architectural side-channel attacks. We introduce a new attack within this class which targets the use of low power cache memories. Although such caches offer an attractive compromise between performance and power consumption within mobile computing devices, we show that they permit attack where a more considered design strategy would not.},
	language = {en},
	booktitle = {Cryptography and {Coding}},
	publisher = {Springer},
	author = {Grabher, Philipp and Großschädl, Johann and Page, Daniel},
	editor = {Galbraith, Steven D.},
	year = {2007},
	keywords = {Branch Prediction, Cache Line, Cache Memory, Instruction Cache, Modular Exponentiation},
	pages = {170--184},
}

@book{page_theoretical_2002,
	title = {Theoretical {Use} of {Cache} {Memory} as a {Cryptanalytic} {Side}-{Channel}},
	abstract = {We expand on the idea, proposed by Kelsey et al. [14], of cache memory being  used as a side-channel which leaks information during the run of a cryptographic  algorithm. By using this side-channel, an attacker may be able to reveal or narrow  the possible values of secret information held on the target device. We describe  an attack which encrypts 2    chosen plaintexts on the target processor in order to  collect cache profiles and then performs around 2    computational steps to recover  the key. As well as describing and simulating the theoretical attack, we discuss  how hardware and algorithmic alterations can be used to defend against such techniques.},
	author = {Page, D.},
	year = {2002},
	file = {Citeseer - Full Text PDF:/home/lucas/archive/Zotero/storage/87SATJU2/Page - 2002 - Theoretical Use of Cache Memory as a Cryptanalytic.pdf:application/pdf},
}

@article{merget_raccoon_2019,
	title = {Raccoon {Attack}: {Finding} and {Exploiting} {Most}-{Signiﬁcant}-{Bit}-{Oracles} in},
	abstract = {Difﬁe-Hellman key exchange (DHKE) is a widely adopted method for exchanging cryptographic key material in realworld protocols like TLS-DH(E). Past attacks on TLS-DH(E) focused on weak parameter choices or missing parameter validation. The conﬁdentiality of the computed DH share, the premaster secret, was never questioned; DHKE is used as a generic method to avoid the security pitfalls of TLS-RSA.},
	language = {en},
	author = {Merget, Robert and Brinkmann, Marcus and Aviram, Nimrod and Somorovsky, Juraj and Mittmann, Johannes},
	year = {2019},
	pages = {19},
	file = {Merget et al. - Raccoon Attack Finding and Exploiting Most-Signiﬁ.pdf:/home/lucas/archive/Zotero/storage/VAMIRY4M/Merget et al. - Raccoon Attack Finding and Exploiting Most-Signiﬁ.pdf:application/pdf},
}

@article{hvass_high-assurance_nodate,
	title = {High-assurance ﬁeld inversion for curve-based cryptography},
	abstract = {Modern cryptography must satisfy a myriad of security properties, ranging from sound hardness assumptions to correct and secure implementations that resist side-channel cryptanalysis. Curve-based cryptography is not diﬀerent in this regard, and substantial progress in the last few decades has been achieved in both selecting parameters and devising secure implementation strategies. In this context, the security of implementations of ﬁeld inversion is sometimes overlooked in the research literature, because (i) the approach based on Fermat’s Little Theorem (FLT) suﬃces performance-wise for many parameters used in practice; (ii) it is typically invoked only at the very end of scalar multiplication or pairing computation, with a small impact in performance; (iii) it is challenging to implement securely for general parameters without a signiﬁcant performance penalty. However, ﬁeld inversion can process sensitive information and must be protected with side-channel countermeasures like any other cryptographic operation, as illustrated by recent attacks [ASS17, AGTB18, AGB20]. In this work, we focus on timing attacks against ﬁeld inversion for primes of cryptographic interest, both in the case when FLT-based inversion can be eﬃciently implemented or not. We extend the Fiat-Cryptography framework, which synthesizes provably correct-by-construction implementations, to implement the Bernstein-Yang constant-time inversion algorithm as a step toward this goal. This allows a correct implementation of prime ﬁeld inversion to be conveniently synthesized for any prime. We benchmark the implementations across a range of primes for curve-based cryptography and they outperform traditional FLT-based approaches in most cases, with observed speedups up to 2.5 for the largest parameters. Our work is already used in production in the MirageOS unikernel operating system1.},
	language = {en},
	author = {Hvass, Benjamin S and Aranha, Diego F and Spitters, Bas},
	pages = {23},
	file = {Hvass et al. - High-assurance ﬁeld inversion for curve-based cryp.pdf:/home/lucas/archive/Zotero/storage/JK5ET46R/Hvass et al. - High-assurance ﬁeld inversion for curve-based cryp.pdf:application/pdf},
}

@misc{wahby_hashing_nodate,
	title = {Hashing to {Elliptic} {Curves}},
	url = {https://tools.ietf.org/html/draft-irtf-cfrg-hash-to-curve-09},
	language = {en},
	urldate = {2021-05-01},
	author = {Wahby, Riad and Wood, Christopher and Faz-Hernández, Armando and Scott, Sam and Sullivan, Nick},
	file = {Snapshot:/home/lucas/archive/Zotero/storage/RAQQERH2/draft-irtf-cfrg-hash-to-curve-09.html:text/html},
}

@inproceedings{zankl_automated_2017,
	address = {Cham},
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {Automated {Detection} of {Instruction} {Cache} {Leaks} in {Modular} {Exponentiation} {Software}},
	isbn = {978-3-319-54669-8},
	doi = {10.1007/978-3-319-54669-8_14},
	abstract = {The shared instruction cache of modern processors is an established side-channel that allows adversaries to observe the execution flow of other applications. This has been shown to be a threat to cryptographic software whose execution flow depends on the processed secrets. Testing implementations for these dependencies, or leaks, is essential to develop protected cryptographic software. In this work, we present an automated testing methodology that allows to detect execution flow leaks in implementations of modular exponentiation, a key operation in schemes like RSA, ElGamal, and Diffie-Hellman. We propose a simple and effective leakage test that captures problematic properties of vulnerable exponentiation algorithms. The execution flow of an implementation is directly monitored during exponentiation using a dynamic binary instrumentation framework. This allows to efficiently detect leaking code with instruction-level granularity in a noiseless and controlled environment. As a practical demonstration, we test multiple RSA implementations of modern cryptographic libraries with the proposed methodology. It reliably detects leaking code in vulnerable implementations and also identifies leaks in a protected implementation that are non-trivial to spot in a code review. We present a fix for these leaks and strongly recommend to also patch the other implementations. Because instruction cache attacks have been shown to be a threat in practice, it seems advisable to integrate an automated leakage test in the software release process of cryptographic libraries.},
	language = {en},
	booktitle = {Smart {Card} {Research} and {Advanced} {Applications}},
	publisher = {Springer International Publishing},
	author = {Zankl, Andreas and Heyszl, Johann and Sigl, Georg},
	editor = {Lemke-Rust, Kerstin and Tunstall, Michael},
	year = {2017},
	keywords = {RSA, Automated software testing, DBI, Granular leakage detection, Noiseless evaluation environment, Non-trivial bug discovery, Open-source crypto library},
	pages = {228--244},
}

@inproceedings{aciicmez_new_2010,
	address = {Berlin, Heidelberg},
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {New {Results} on {Instruction} {Cache} {Attacks}},
	isbn = {978-3-642-15031-9},
	doi = {10.1007/978-3-642-15031-9_8},
	abstract = {We improve instruction cache data analysis techniques with a framework based on vector quantization and hidden Markov models. As a result, we are capable of carrying out efficient automated attacks using live I-cache timing data. Using this analysis technique, we run an I-cache attack on OpenSSL’s DSA implementation and recover keys using lattice methods. Previous I-cache attacks were proof-of-concept: we present results of an actual attack in a real-world setting, proving these attacks to be realistic. We also present general software countermeasures, along with their performance impact, that are not algorithm specific and can be employed at the kernel and/or compiler level.},
	language = {en},
	booktitle = {Cryptographic {Hardware} and {Embedded} {Systems}, {CHES} 2010},
	publisher = {Springer},
	author = {Acıiçmez, Onur and Brumley, Billy Bob and Grabher, Philipp},
	editor = {Mangard, Stefan and Standaert, François-Xavier},
	year = {2010},
	keywords = {Cache Line, Context Switch, Hide Markov Model, Performance Overhead, Vector Quantization},
	pages = {110--124},
	file = {Springer Full Text PDF:/home/lucas/archive/Zotero/storage/PJMDTUTM/Acıiçmez et al. - 2010 - New Results on Instruction Cache Attacks.pdf:application/pdf},
}

@inproceedings{aciicmez_yet_2007,
	address = {New York, NY, USA},
	series = {{CSAW} '07},
	title = {Yet another {MicroArchitectural} {Attack}: exploiting {I}-{Cache}},
	isbn = {978-1-59593-890-9},
	shorttitle = {Yet another {MicroArchitectural} {Attack}},
	url = {https://doi.org/10.1145/1314466.1314469},
	doi = {10.1145/1314466.1314469},
	abstract = {MicroArchitectural Attacks (MA), which can be considered as a special form of Side-Channel Analysis, exploit microarchitectural functionalities of processor implementations and can compromise the security of computational environments even in the presence of sophisticated protection mechanisms like virtualization and sandboxing. This newly evolving research area has attracted significant interest due to the broad application range and the potentials of these attacks. Cache Analysis and Branch Prediction Analysis were the only types of MA that had been known publicly. In this paper, we introduce Instruction Cache (I-Cache) as yet another source of MA and present our experimental results which clearly prove the practicality and danger of I-Cache Attacks.},
	urldate = {2021-05-15},
	booktitle = {Proceedings of the 2007 {ACM} workshop on {Computer} security architecture},
	publisher = {Association for Computing Machinery},
	author = {Aciiçmez, Onur},
	month = nov,
	year = {2007},
	keywords = {RSA, instruction cache, MicroArchitectural analysis, modular exponentiation, Montgomery Multiplication, side channel analysis},
	pages = {11--18},
	file = {Full Text PDF:/home/lucas/archive/Zotero/storage/NTWIB2EZ/Aciiçmez - 2007 - Yet another MicroArchitectural Attack exploiting .pdf:application/pdf},
}

@article{ge_survey_2018,
	title = {A survey of microarchitectural timing attacks and countermeasures on contemporary hardware},
	volume = {8},
	issn = {2190-8508, 2190-8516},
	url = {http://link.springer.com/10.1007/s13389-016-0141-6},
	doi = {10.1007/s13389-016-0141-6},
	abstract = {Microarchitectural timing channels expose hidden hardware state though timing. We survey recent attacks that exploit microarchitectural features in shared hardware, especially as they are relevant for cloud computing. We classify types of attacks according to a taxonomy of the shared resources leveraged for such attacks. Moreover, we take a detailed look at attacks used against shared caches. We survey existing countermeasures. We ﬁnally discuss trends in the attacks, challenges to combating them, and future directions, especially with respect to hardware support.},
	language = {en},
	number = {1},
	urldate = {2021-05-15},
	journal = {Journal of Cryptographic Engineering},
	author = {Ge, Qian and Yarom, Yuval and Cock, David and Heiser, Gernot},
	year = {2018},
	pages = {1--27},
	file = {Ge et al. - 2018 - A survey of microarchitectural timing attacks and .pdf:/home/lucas/archive/Zotero/storage/VEGD3FQZ/Ge et al. - 2018 - A survey of microarchitectural timing attacks and .pdf:application/pdf},
}

@article{kocher_cryptanalysis_nodate,
	title = {Cryptanalysis of {Di} e-{Hellman}, {RSA}, {DSS}, and {Other} {Systems} {Using} {Timing} {Attacks}},
	abstract = {Cryptosystems often take slightly di erent amounts of time to process di erent messages. With network-based cryptosystems, cryptographic tokens, and many other applications, attackers can measure the amount of time used to complete cryptographic operations. This abstract shows that timing channels can, and often do, leak key material. The attacks are particularly alarming because they often require only known ciphertext, work even if timing measurements are somewhat inaccurate, are computationally easy, and are di cult to detect. This preliminary draft outlines attacks that can nd secret exponents in Di e-Hellman key exchange, factor RSA keys, and nd DSS secret parameters. Other symmetric and asymmetric cryptographic functions are also at risk. A complete description of the attack will be presented in a full paper, to be released later. I conclude by noting that closing timing channels is often more di cult than might be expected.},
	language = {en},
	author = {Kocher, Paul C},
	pages = {6},
	file = {Kocher - Cryptanalysis of Di e-Hellman, RSA, DSS, and Other.pdf:/home/lucas/archive/Zotero/storage/B4UQMSEG/Kocher - Cryptanalysis of Di e-Hellman, RSA, DSS, and Other.pdf:application/pdf},
}

@article{hellman_overview_1978,
	title = {An {Overview} of {Public} {Key} {Cryptography}},
	language = {en},
	journal = {IEEE COMMUNICATIONS SOCIETY MAGAZINE},
	author = {Hellman, Martin E},
	year = {1978},
	pages = {9},
	file = {Hellman - 1978 - An Overview of Public Key Cryptography.pdf:/home/lucas/archive/Zotero/storage/8URLMAUA/Hellman - 1978 - An Overview of Public Key Cryptography.pdf:application/pdf},
}

@article{kocher_cryptanalysis_1995,
	title = {Cryptanalysis of {Diffie}-{Hellman}, {RSA}, {DSS}, and {Other} {Systems} {Using} {Timing} {Attacks}},
	abstract = {Cryptosystems often take slightly di erent amounts of time to process di erent messages. With network-based cryptosystems, cryptographic tokens, and many other applications, attackers can measure the amount of time used to complete cryptographic operations. This abstract shows that timing channels can, and often do, leak key material. The attacks are particularly alarming because they often require only known ciphertext, work even if timing measurements are somewhat inaccurate, are computationally easy, and are di cult to detect. This preliminary draft outlines attacks that can nd secret exponents in Di e-Hellman key exchange, factor RSA keys, and nd DSS secret parameters. Other symmetric and asymmetric cryptographic functions are also at risk. A complete description of the attack will be presented in a full paper, to be released later. I conclude by noting that closing timing channels is often more di cult than might be expected.},
	language = {en},
	author = {Kocher, Paul C},
	year = {1995},
	pages = {6},
	file = {Kocher - Cryptanalysis of Di e-Hellman, RSA, DSS, and Other.pdf:/home/lucas/archive/Zotero/storage/5TH2WQSW/Kocher - Cryptanalysis of Di e-Hellman, RSA, DSS, and Other.pdf:application/pdf},
}

@misc{ford_proposal_2017,
	title = {proposal: math/big: support for constant-time arithmetic - {Issue} \#20654 - golang/go},
	shorttitle = {proposal},
	url = {https://github.com/golang/go/issues/20654},
	abstract = {Problem: Constant-Time Arithmetic for Cryptographic Uses The math/big package naturally and inevitably gets used for cryptographic purposes, including in the standard Go crypto libraries. However, ...},
	language = {en},
	urldate = {2021-05-16},
	journal = {GitHub},
	author = {Ford, Bryan},
	year = {2017},
	file = {Snapshot:/home/lucas/archive/Zotero/storage/MARVSL8N/20654.html:text/html},
}

@article{schindler_exponent_nodate,
	title = {Exponent {Blinding} {May} {Not} {Prevent} {Timing} {Attacks} on {RSA}},
	abstract = {The references [9, 3, 1] treat timing attacks on RSA with CRT and Montgomery’s multiplication algorithm in unprotected implementations. It has been widely believed that exponent blinding would prevent any timing attack on RSA. At cost of signiﬁcantly more timing measurements this paper extends the before-mentioned attacks to RSA with CRT, Montgomery’s multiplication algorithm and exponent blinding. Simulation experiments are conducted, which conﬁrm the theoretical results. Eﬀective countermeasures exist.},
	language = {en},
	author = {Schindler, Werner},
	pages = {23},
	file = {Schindler - Exponent Blinding May Not Prevent Timing Attacks o.pdf:/home/lucas/archive/Zotero/storage/9IQZNWUR/Schindler - Exponent Blinding May Not Prevent Timing Attacks o.pdf:application/pdf},
}

@article{rivest_method_1978,
	title = {A method for obtaining digital signatures and public-key cryptosystems},
	volume = {21},
	issn = {0001-0782},
	url = {https://doi.org/10.1145/359340.359342},
	doi = {10.1145/359340.359342},
	abstract = {An encryption method is presented with the novel property that publicly revealing an encryption key does not thereby reveal the corresponding decryption key. This has two important consequences: (1) Couriers or other secure means are not needed to transmit keys, since a message can be enciphered using an encryption key publicly revealed by the intented recipient. Only he can decipher the message, since only he knows the corresponding decryption key. (2) A message can be “signed” using a privately held decryption key. Anyone can verify this signature using the corresponding publicly revealed encryption key. Signatures cannot be forged, and a signer cannot later deny the validity of his signature. This has obvious applications in “electronic mail” and “electronic funds transfer” systems. A message is encrypted by representing it as a number M, raising M to a publicly specified power e, and then taking the remainder when the result is divided by the publicly specified product, n, of two large secret primer numbers p and q. Decryption is similar; only a different, secret, power d is used, where e * d ≡ 1(mod (p - 1) * (q - 1)). The security of the system rests in part on the difficulty of factoring the published divisor, n.},
	number = {2},
	urldate = {2021-05-17},
	journal = {Communications of the ACM},
	author = {Rivest, R. L. and Shamir, A. and Adleman, L.},
	month = feb,
	year = {1978},
	keywords = {authentication, cryptography, digital signatures, electronic funds transfer, electronic mail, factorization, message-passing, prime number, privacy, public-key cryptosystems, security},
	pages = {120--126},
	file = {Full Text PDF:/home/lucas/archive/Zotero/storage/SHBQ3HBA/Rivest et al. - 1978 - A method for obtaining digital signatures and publ.pdf:application/pdf},
}

@techreport{technology_digital_1994,
	title = {Digital {Signature} {Standard} ({DSS})},
	url = {https://csrc.nist.gov/publications/detail/fips/186/archive/1994-05-19},
	abstract = {This standard specifies a Digital Signature Algorithm (DSA) which can be used to generate a digital signature. Digital signatures are used to detect unauthorized modifications to data and to authenticate the identity of the signatory. In addition, the recipient of signed data can use a digital signature in proving to a third party that the signature was in fact generated by the signatory. This is known as nonrepudiation since the signatory cannot, at a later time, repudiate the signature.},
	language = {en},
	number = {Federal Information Processing Standard (FIPS) 186 (Withdrawn)},
	urldate = {2021-05-17},
	institution = {U.S. Department of Commerce},
	author = {Technology, National Institute of Standards and},
	month = may,
	year = {1994},
	doi = {10.6028/NIST.FIPS.186},
	file = {Full Text PDF:/home/lucas/archive/Zotero/storage/4BS3DY2L/Technology - 1994 - Digital Signature Standard (DSS).pdf:application/pdf;Snapshot:/home/lucas/archive/Zotero/storage/K4483PWA/1994-05-19.html:text/html},
}

@techreport{technology_digital_2013,
	title = {Digital {Signature} {Standard} ({DSS})},
	url = {https://csrc.nist.gov/publications/detail/fips/186/4/final},
	abstract = {The Standard specifies a suite of algorithms that can be used to generate a digital signature. Digital signatures are used to detect unauthorized modifications to data and to authenticate the identity of the signatory. In addition, the recipient of signed data can use a digital signature as evidence in demonstrating to a third party that the signature was, in fact, generated by the claimed signatory. This is known as non-repudiation, since the signatory cannot easily repudiate the signature at a later time. This Standard specifies three techniques for the generation and verification of digital signatures: DSA, ECDSA and RSA. This revision increases the length of the keys allowed for DSA, provides additional requirements for the use of ECDSA and RSA, and includes requirements for obtaining assurances necessary for valid digital signatures.},
	language = {en},
	number = {Federal Information Processing Standard (FIPS) 186-4},
	urldate = {2021-05-17},
	institution = {U.S. Department of Commerce},
	author = {Technology, National Institute of Standards and},
	month = jul,
	year = {2013},
	doi = {10.6028/NIST.FIPS.186-4},
	file = {Full Text PDF:/home/lucas/archive/Zotero/storage/CQCYHH7G/Technology - 2013 - Digital Signature Standard (DSS).pdf:application/pdf;Snapshot:/home/lucas/archive/Zotero/storage/AI3ZN6XJ/final.html:text/html},
}

@misc{meier_cronokirbysafenum_2021,
	title = {cronokirby/safenum},
	copyright = {View license         ,                      View license},
	url = {https://github.com/cronokirby/safenum},
	abstract = {Constant time big numbers for Go. Contribute to cronokirby/safenum development by creating an account on GitHub.},
	urldate = {2021-05-17},
	author = {Meier, Lúcás Críostóir},
	month = may,
	year = {2021},
}

@misc{the_go_authors_go_nodate,
	title = {The {Go} {Programming} {Language} {Specification} - {The} {Go} {Programming} {Language}},
	url = {https://golang.org/ref/spec},
	urldate = {2021-05-17},
	author = {The Go Authors},
	file = {The Go Programming Language Specification - The Go Programming Language:/home/lucas/archive/Zotero/storage/AM6KG4MM/spec.html:text/html},
}

@inproceedings{miller_use_1986,
	address = {Berlin, Heidelberg},
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {Use of {Elliptic} {Curves} in {Cryptography}},
	isbn = {978-3-540-39799-1},
	doi = {10.1007/3-540-39799-X_31},
	abstract = {We discuss the use of elliptic curves in cryptography. In particular, we propose an analogue of the Diffie-Hellmann key exchange protocol which appears to be immune from attacks of the style of Western, Miller, and Adleman. With the current bounds for infeasible attack, it appears to be about 20\% faster than the Diffie-Hellmann scheme over GF(p). As computational power grows, this disparity should get rapidly bigger.},
	language = {en},
	booktitle = {Advances in {Cryptology} — {CRYPTO} ’85 {Proceedings}},
	publisher = {Springer},
	author = {Miller, Victor S.},
	editor = {Williams, Hugh C.},
	year = {1986},
	keywords = {Algebraic Group, Discrete Logarithm, Elliptic Curf, Elliptic Curve, Finite Field},
	pages = {417--426},
	file = {Springer Full Text PDF:/home/lucas/archive/Zotero/storage/D2Y25TSP/Miller - 1986 - Use of Elliptic Curves in Cryptography.pdf:application/pdf},
}

@inproceedings{kelsey_side_1998,
	address = {Berlin, Heidelberg},
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {Side channel cryptanalysis of product ciphers},
	isbn = {978-3-540-49784-4},
	doi = {10.1007/BFb0055858},
	abstract = {Building on the work of Kocher [Koc96], we introduce the notion of side-channel cryptanalysis: cryptanalysis using implementation data. We discuss the notion of side-channel attacks and the vulnerabilities they introduce, demonstrate side-channel attacks against three product ciphers—timing attack against IDEA, processor-flag attack against RC5, and Hamming weight attack against DES—and then generalize our research to other cryptosystems.},
	language = {en},
	booktitle = {Computer {Security} — {ESORICS} 98},
	publisher = {Springer},
	author = {Kelsey, John and Schneier, Bruce and Wagner, David and Hall, Chris},
	editor = {Quisquater, Jean-Jacques and Deswarte, Yves and Meadows, Catherine and Gollmann, Dieter},
	year = {1998},
	keywords = {cryptanalysis, product ciphers, side channels, timing attacks},
	pages = {97--110},
	file = {Springer Full Text PDF:/home/lucas/archive/Zotero/storage/F4VWNJKY/Kelsey et al. - 1998 - Side channel cryptanalysis of product ciphers.pdf:application/pdf},
}

@inproceedings{brumley_remote_2011,
	address = {Berlin, Heidelberg},
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {Remote {Timing} {Attacks} {Are} {Still} {Practical}},
	isbn = {978-3-642-23822-2},
	doi = {10.1007/978-3-642-23822-2_20},
	abstract = {For over two decades, timing attacks have been an active area of research within applied cryptography. These attacks exploit cryptosystem or protocol implementations that do not run in constant time. When implementing an elliptic curve cryptosystem with a goal to provide side-channel resistance, the scalar multiplication routine is a critical component. In such instances, one attractive method often suggested in the literature is Montgomery’s ladder that performs a fixed sequence of curve and field operations. This paper describes a timing attack vulnerability in OpenSSL’s ladder implementation for curves over binary fields. We use this vulnerability to steal the private key of a TLS server where the server authenticates with ECDSA signatures. Using the timing of the exchanged messages, the messages themselves, and the signatures, we mount a lattice attack that recovers the private key. Finally, we describe and implement an effective countermeasure.},
	language = {en},
	booktitle = {Computer {Security} – {ESORICS} 2011},
	publisher = {Springer},
	author = {Brumley, Billy Bob and Tuveri, Nicola},
	editor = {Atluri, Vijay and Diaz, Claudia},
	year = {2011},
	keywords = {timing attacks, elliptic curve cryptography, lattice attacks, Side-channel attacks},
	pages = {355--371},
	file = {Springer Full Text PDF:/home/lucas/archive/Zotero/storage/ZY7JPZTT/Brumley and Tuveri - 2011 - Remote Timing Attacks Are Still Practical.pdf:application/pdf},
}

@misc{pornin_bearssl_nodate,
	title = {{BearSSL} - {Constant}-{Time} {Mul}},
	url = {https://www.bearssl.org/ctmul.html},
	urldate = {2021-05-20},
	author = {Pornin, Thomas},
	file = {BearSSL - Constant-Time Mul:/home/lucas/archive/Zotero/storage/5JS3V8YC/ctmul.html:text/html},
}

@inproceedings{aciicmez_predicting_2006,
	address = {Berlin, Heidelberg},
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {Predicting {Secret} {Keys} {Via} {Branch} {Prediction}},
	isbn = {978-3-540-69328-4},
	doi = {10.1007/11967668_15},
	abstract = {This paper announces a new software side-channel attack — enabled by the branch prediction capability common to all modern high-performance CPUs. The penalty paid (extra clock cycles) for a mispredicted branch can be used for cryptanalysis of cryptographic primitives that employ a data-dependent program flow. Analogous to the recently described cache-based side-channel attacks our attacks also allow an unprivileged process to attack other processes running in parallel on the same processor, despite sophisticated partitioning methods such as memory protection, sandboxing or even virtualization. In this paper, we will discuss several such attacks for the example of RSA, and experimentally show their applicability to real systems, such as OpenSSL and Linux. Moreover, we will also demonstrate the strength of the branch prediction side-channel attack by rendering the obvious countermeasure in this context (Montgomery Multiplication with dummy-reduction) as useless. Although the deeper consequences of the latter result make the task of writing an efficient and secure modular exponentiation (or scalar multiplication on an elliptic curve) a challenging task, we will eventually suggest some countermeasures to mitigate branch prediction side-channel attacks.},
	language = {en},
	booktitle = {Topics in {Cryptology} – {CT}-{RSA} 2007},
	publisher = {Springer},
	author = {Acıiçmez, Onur and Koç, Çetin Kaya and Seifert, Jean-Pierre},
	editor = {Abe, Masayuki},
	year = {2006},
	keywords = {RSA, Branch Prediction, Modular Exponentiation, Montgomery Multiplication, Side Channel Analysis, Simultaneous Multi-threading},
	pages = {225--242},
	file = {Submitted Version:/home/lucas/archive/Zotero/storage/MQ6JHKRD/Acıiçmez et al. - 2006 - Predicting Secret Keys Via Branch Prediction.pdf:application/pdf},
}

@inproceedings{aciicmez_power_2007,
	address = {New York, NY, USA},
	series = {{ASIACCS} '07},
	title = {On the power of simple branch prediction analysis},
	isbn = {978-1-59593-574-8},
	url = {https://doi.org/10.1145/1229285.1266999},
	doi = {10.1145/1229285.1266999},
	abstract = {Very recently, a new software side-channel attack, called Branch Prediction Analysis (BPA) attack, has been discovered and also demonstrated to be practically feasible on popular commodity PC platforms. While the above recent attack still had the flavor of a classical timing attack against RSA, where one uses many execution-time measurements under the same key in order to statistically amplify some small but key-dependent timing differences, we dramatically improve upon the former result. We prove that a carefully written spy-process running simultaneously with an RSA-process, is able to collect during one single RSA signing execution almost all of the secret key bits. We call such an attack, analyzing the CPU's Branch Predictor states through spying on a single quasi-parallel computation process, a Simple Branch Prediction Analysis (SBPA) attack --- sharply differentiating it from those one relying on statistical methods and requiring many computation measurements under the same key. The successful extraction of almost all secret key bits by our SBPA attack against an openSSL RSA implementation proves that the often recommended blinding or so called randomization techniques to protect RSA against side-channel attacks are, in the context of SBPA attacks, totally useless. Additional to that very crucial security implication, targeted at such implementations which are assumed to be at least statistically secure, our successful SBPA attack also bears another equally critical security implication. Namely, in the context of simple side-channel attacks, it is widely believed that equally balancing the operations after branches is a secure countermeasure against such simple attacks. Unfortunately, this is not true, as even such "balanced branch" implementations can be completely broken by our SBPA attacks. Moreover, despite sophisticated hardware-assisted partitioning methods such as memory protection, sandboxing or even virtualization, SBPA attacks empower an unprivileged process to successfully attack other processes running in parallel on the same processor. Thus, we conclude that SBPA attacks are much more dangerous than previously anticipated, as they obviously do not belong to the same category as pure timing attacks.},
	urldate = {2021-05-20},
	booktitle = {Proceedings of the 2nd {ACM} symposium on {Information}, computer and communications security},
	publisher = {Association for Computing Machinery},
	author = {Aciiçmez, Onur and Koç, Çetin Kaya and Seifert, Jean-Pierre},
	month = mar,
	year = {2007},
	keywords = {RSA, modular exponentiation, side channel analysis, branch prediction analysis},
	pages = {312--320},
	file = {Full Text PDF:/home/lucas/archive/Zotero/storage/F3JGFC9T/Aciiçmez et al. - 2007 - On the power of simple branch prediction analysis.pdf:application/pdf},
}

@inproceedings{evtyushkin_jump_2016,
	title = {Jump over {ASLR}: {Attacking} branch predictors to bypass {ASLR}},
	shorttitle = {Jump over {ASLR}},
	doi = {10.1109/MICRO.2016.7783743},
	abstract = {Address Space Layout Randomization (ASLR) is a widely-used technique that protects systems against a range of attacks. ASLR works by randomizing the offset of key program segments in virtual memory, making it difficult for an attacker to derive the addresses of specific code objects and consequently redirect the control flow to this code. In this paper, we develop an attack to derive kernel and user-level ASLR offset using a side-channel attack on the branch target buffer (BTB). Our attack exploits the observation that an adversary can create BTB collisions between the branch instructions of the attacker process and either the user-level victim process or on the kernel executing on its behalf. These collisions, in turn, can impact the timing of the attacker's code, allowing the attacker to identify the locations of known branch instructions in the address space of the victim process or the kernel. We demonstrate that our attack can reliably recover kernel ASLR in about 60 milliseconds when performed on a real Haswell processor running a recent version of Linux. Finally, we describe several possible protection mechanisms, both in software and in hardware.},
	booktitle = {2016 49th {Annual} {IEEE}/{ACM} {International} {Symposium} on {Microarchitecture} ({MICRO})},
	author = {Evtyushkin, Dmitry and Ponomarev, Dmitry and Abu-Ghazaleh, Nael},
	month = oct,
	year = {2016},
	keywords = {Address Space Layout Randomization, Bypass, Exploit Mitigation, Hardware, Kernel, Kernel Vulnerabilities, Layout, Process control, Reliability, Side Channel, Timing, Timing Attacks, Timing Channel},
	pages = {1--13},
	file = {IEEE Xplore Full Text PDF:/home/lucas/archive/Zotero/storage/R4QXWF39/Evtyushkin et al. - 2016 - Jump over ASLR Attacking branch predictors to byp.pdf:application/pdf;IEEE Xplore Abstract Record:/home/lucas/archive/Zotero/storage/5YPECVH2/7783743.html:text/html},
}

@inproceedings{bernstein_word_2013,
	title = {A word of warning},
	volume = {13},
	booktitle = {Workshop on {Cryptographic} {Hardware} and {Embedded} {Systems}},
	author = {Bernstein, Daniel J and Schwabe, Peter},
	year = {2013},
}

@inproceedings{osvik_cache_2006,
	address = {Berlin, Heidelberg},
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {Cache {Attacks} and {Countermeasures}: {The} {Case} of {AES}},
	isbn = {978-3-540-32648-9},
	shorttitle = {Cache {Attacks} and {Countermeasures}},
	doi = {10.1007/11605805_1},
	abstract = {We describe several software side-channel attacks based on inter-process leakage through the state of the CPU’s memory cache. This leakage reveals memory access patterns, which can be used for cryptanalysis of cryptographic primitives that employ data-dependent table lookups. The attacks allow an unprivileged process to attack other processes running in parallel on the same processor, despite partitioning methods such as memory protection, sandboxing and virtualization. Some of our methods require only the ability to trigger services that perform encryption or MAC using the unknown key, such as encrypted disk partitions or secure network links. Moreover, we demonstrate an extremely strong type of attack, which requires knowledge of neither the specific plaintexts nor ciphertexts, and works by merely monitoring the effect of the cryptographic process on the cache. We discuss in detail several such attacks on AES, and experimentally demonstrate their applicability to real systems, such as OpenSSL and Linux’s dm-crypt encrypted partitions (in the latter case, the full key can be recovered after just 800 writes to the partition, taking 65 milliseconds). Finally, we describe several countermeasures for mitigating such attacks.},
	language = {en},
	booktitle = {Topics in {Cryptology} – {CT}-{RSA} 2006},
	publisher = {Springer},
	author = {Osvik, Dag Arne and Shamir, Adi and Tromer, Eran},
	editor = {Pointcheval, David},
	year = {2006},
	keywords = {cryptanalysis, AES, cache, memory access, side-channel attack},
	pages = {1--20},
}

@inproceedings{brickell_technologies_2011,
	title = {Technologies to improve platform security},
	volume = {11},
	booktitle = {Workshop on {Cryptographic} {Hardware} and {Embedded} {Systems}},
	author = {Brickell, Ernie},
	year = {2011},
}

@misc{meier_cronokirbyctcrypto_2021,
	title = {cronokirby/ctcrypto},
	copyright = {View license         ,                      View license},
	url = {https://github.com/cronokirby/ctcrypto},
	abstract = {Proof-of-Concept for using https://github.com/cronokirby/safenum in crypto code},
	urldate = {2021-05-22},
	author = {Meier, Lúcás Críostóir},
	month = may,
	year = {2021},
	note = {original-date: 2021-04-17T14:26:20Z},
}

@inproceedings{yan_modified_2007,
	title = {Modified modular inversion algorithm for {VLSI} implementation},
	doi = {10.1109/ICASIC.2007.4415574},
	abstract = {This paper proposes a new, efficient algorithm for modular inversion in Galois field GF(p). This algorithm reduces the number of operations cycles required by 31\% when compared with previous algorithms reported in the literature. The 256 bit modular inversion circuit based on the proposed algorithm is implemented in 0.18 mum CMOS standard cell technology. The synthesis result shows a significant speed-up in the same area complexity.},
	booktitle = {2007 7th {International} {Conference} on {ASIC}},
	author = {Yan, Xiaodong and Li, Shuguo},
	month = oct,
	year = {2007},
	note = {ISSN: 2162-755X},
	keywords = {Hardware, Algorithm design and analysis, Circuit synthesis, CMOS technology, Communication system security, Galois fields, Microelectronics, Personal digital assistants, Public key cryptography, Very large scale integration},
	pages = {90--93},
	file = {IEEE Xplore Abstract Record:/home/lucas/archive/Zotero/storage/7YUCYST4/4415574.html:text/html},
}

@article{kaya_koc_analyzing_1996-1,
	title = {Analyzing and comparing {Montgomery} multiplication algorithms},
	volume = {16},
	issn = {1937-4143},
	doi = {10.1109/40.502403},
	abstract = {Montgomery multiplication methods constitute the core of modular exponentiation, the most popular operation for encrypting and signing digital data in public-key cryptography. In this article, we study the operations involved in computing the Montgomery product, describe several high-speed, space-efficient algorithms for computing MonPro(a, b), and analyze their time and space requirements. Our focus is to collect several alternatives for Montgomery multiplication, three of which are new. However, we do not compare the Montgomery techniques to other modular multiplication approaches.},
	number = {3},
	journal = {IEEE Micro},
	author = {Kaya Koc, C. and Acar, T. and Kaliski, B.S.},
	month = jun,
	year = {1996},
	note = {Conference Name: IEEE Micro},
	keywords = {Timing, Algorithm design and analysis, Computer aided instruction, Difference equations, Microprocessors, Performance analysis, Read-write memory, Registers},
	pages = {26--33},
	file = {IEEE Xplore Abstract Record:/home/lucas/archive/Zotero/storage/EF3B5IK2/502403.html:text/html},
}

@misc{meier_cronokirbyctrsa_nodate,
	title = {cronokirby/ctrsa: {Trying} to make crypto/rsa constant-time},
	url = {https://github.com/cronokirby/ctrsa},
	urldate = {2021-05-24},
	author = {Meier, Lúcás Críostóir},
	file = {cronokirby/ctrsa\: Trying to make crypto/rsa constant-time:/home/lucas/archive/Zotero/storage/9935HCLP/ctrsa.html:text/html},
}

@article{buhler_basic_2008,
	title = {Basic algorithms in number theory},
	language = {en},
	author = {Buhler, Joe and Wagon, Stan},
	year = {2008},
	pages = {44},
	file = {Buhler and Wagon - Basic algorithms in number theory.pdf:/home/lucas/archive/Zotero/storage/3XE3UR5M/Buhler and Wagon - Basic algorithms in number theory.pdf:application/pdf},
}

@misc{mcloughlin_mmcloughlinavo_2021,
	title = {mmcloughlin/avo},
	copyright = {BSD-3-Clause},
	url = {https://github.com/mmcloughlin/avo},
	abstract = {Generate x86 Assembly with Go},
	urldate = {2021-06-09},
	author = {McLoughlin, Michael},
	month = jun,
	year = {2021},
	note = {original-date: 2018-11-04T17:44:21Z},
	keywords = {assembly, code-generation, go, golang, x86-64},
}
